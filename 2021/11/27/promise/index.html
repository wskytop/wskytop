<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Promise的理解和手撕代码 | Hugh&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Hugh,Hugh's Blog" />
  
  <meta name="description" content="一、什么是Promise？我们用Promise来解决什么问题?  Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise的理解和手撕代码">
<meta property="og:url" content="https://wskytop.gitee.io/2021/11/27/promise/index.html">
<meta property="og:site_name" content="Hugh&#39;s Blog">
<meta property="og:description" content="一、什么是Promise？我们用Promise来解决什么问题?  Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/1637880bdb32bee3~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16376a95ffa3b13c~tplv-t2oaga2asx-watermark.awebp">
<meta property="article:published_time" content="2021-11-26T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-27T05:23:06.224Z">
<meta property="article:author" content="Hugh">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-watermark.awebp">
  
  
    <link rel="icon" href="images/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Hugh&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Hugh&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个不专注 WEB 开发的日常博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Hugh" target="_blank" href="//wskytop.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/wskytop">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Promise的理解和手撕代码
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/notes/">notes</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-11-27
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h3 id="一、什么是Promise？我们用Promise来解决什么问题"><a href="#一、什么是Promise？我们用Promise来解决什么问题" class="headerlink" title="一、什么是Promise？我们用Promise来解决什么问题?"></a>一、什么是Promise？我们用Promise来解决什么问题?</h3><hr>
<blockquote>
<p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</p>
</blockquote>
<p>一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。</p>
<p>这时候我们的promise就应运而生、粉墨登场了</p>
<p>promise是用来解决两个问题的：</p>
<ul>
<li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li>
<li>promise可以支持多个并发的请求，获取并发请求中的数据</li>
<li>这个promise可以解决异步的问题，本身不能说promise是异步的</li>
</ul>
<h3 id="二、es6-promise用法大全"><a href="#二、es6-promise用法大全" class="headerlink" title="二、es6 promise用法大全"></a>二、es6 promise用法大全</h3><hr>
<p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //做一些异步操作</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;执行完成&#x27;);</span><br><span class="line">        resolve(&#x27;我是成功！！&#x27;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：</p>
<ul>
<li>resolve ：异步操作执行成功后的回调函数</li>
<li>reject：异步操作执行失败后的回调函数</li>
</ul>
<h4 id="then-链式操作的用法"><a href="#then-链式操作的用法" class="headerlink" title="then 链式操作的用法"></a>then 链式操作的用法</h4><hr>
<p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a>reject的用法</h4><hr>
<p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	//做一些异步操作</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        //生成1-10的随机数</span><br><span class="line">    	var num = Math.ceil(Math.random()*10); </span><br><span class="line">    	if(num&lt;=5)&#123;</span><br><span class="line">   	 		resolve(num);</span><br><span class="line">		&#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            reject(&#x27;数字太大了&#x27;);</span><br><span class="line">         &#125;</span><br><span class="line">   	&#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">    &#125;,(err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果:</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-watermark.awebp" alt="img">或者    <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h4 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h4><hr>
<p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">    console.log(somedata); //此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/1637880bdb32bee3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p>
<h4 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h4><hr>
<blockquote>
<p>谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象</p>
</blockquote>
<p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let Promise1 = new Promise(function(resolve, reject)&#123;&#125;)</span><br><span class="line">let Promise2 = new Promise(function(resolve, reject)&#123;&#125;)</span><br><span class="line">let Promise3 = new Promise(function(resolve, reject)&#123;&#125;)</span><br><span class="line"></span><br><span class="line">let p = Promise.all([Promise1, Promise2, Promise3])</span><br><span class="line"></span><br><span class="line">p.then(funciton()&#123;</span><br><span class="line">  // 三个都成功则成功  </span><br><span class="line">&#125;, function()&#123;</span><br><span class="line">  // 只要有失败，则失败 </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？<em>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p>
<h4 id="race的用法：谁跑的快，以谁为准执行回调"><a href="#race的用法：谁跑的快，以谁为准执行回调" class="headerlink" title="race的用法：谁跑的快，以谁为准执行回调"></a>race的用法：谁跑的快，以谁为准执行回调</h4><hr>
<p>race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">   function requestImg()&#123;</span><br><span class="line">       var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">           var img = new Image();</span><br><span class="line">           img.onload = function()&#123;</span><br><span class="line">               resolve(img);</span><br><span class="line">           &#125;</span><br><span class="line">           img.src = &#x27;图片的路径&#x27;;</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line">   //延时函数，用于给请求计时</span><br><span class="line">   function timeout()&#123;</span><br><span class="line">       var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">           setTimeout(() =&gt; &#123;</span><br><span class="line">               reject(&#x27;图片请求超时&#x27;);</span><br><span class="line">           &#125;, 5000);</span><br><span class="line">       &#125;);</span><br><span class="line">       return p;</span><br><span class="line">   &#125;</span><br><span class="line">   Promise.race([requestImg(), timeout()]).then((data) =&gt;&#123;</span><br><span class="line">       console.log(data);</span><br><span class="line">   &#125;).catch((err) =&gt; &#123;</span><br><span class="line">       console.log(err);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p>requestImg函数会异步请求一张图片，我把地址写为”图片的路径”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16376a95ffa3b13c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h3 id="三、根据promiseA-实现一个自己的promise"><a href="#三、根据promiseA-实现一个自己的promise" class="headerlink" title="三、根据promiseA+实现一个自己的promise"></a>三、根据promiseA+实现一个自己的promise</h3><hr>
<h4 id="步骤一：实现成功和失败的回调方法"><a href="#步骤一：实现成功和失败的回调方法" class="headerlink" title="步骤一：实现成功和失败的回调方法"></a>步骤一：实现成功和失败的回调方法</h4><hr>
<p>要实现上面代码中的功能，也是promise最基本的功能。首先，需要创建一个构造函数promise，创建一个promisel类，在使用的时候传入了一个执行器executor，executor会传入两个参数：成功(resolve)和失败(reject)。之前说过，只要成功，就不会失败，只要失败就不会成功。所以，默认状态下，在调用成功时，就返回成功态，调用失败时，返回失败态。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor (executor)&#123;</span><br><span class="line">        //默认状态是等待状态</span><br><span class="line">        this.status = &#x27;panding&#x27;;</span><br><span class="line">        this.value = undefined;</span><br><span class="line">        this.reason = undefined;</span><br><span class="line">        //存放成功的回调</span><br><span class="line">        this.onResolvedCallbacks = [];</span><br><span class="line">        //存放失败的回调</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line">        let resolve = (data) =&gt; &#123;//this指的是实例</span><br><span class="line">            if(this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">                this.value = data;</span><br><span class="line">                this.status = &quot;resolved&quot;;</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn =&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        let reject = (reason) =&gt; &#123;</span><br><span class="line">            if(this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">                this.reason = reason;</span><br><span class="line">                this.status = &#x27;rejected&#x27;;</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn =&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;//执行时可能会发生异常</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;catch (e)&#123;</span><br><span class="line">            reject(e);//promise失败了</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>promise A+规范规定，在有异常错误时，则执行失败函数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor (executor)&#123;</span><br><span class="line">    ......      try&#123;</span><br><span class="line">        executor(resolve,reject);</span><br><span class="line">      &#125;catch(e)&#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤二：then方法链式调用"><a href="#步骤二：then方法链式调用" class="headerlink" title="步骤二：then方法链式调用"></a>步骤二：then方法链式调用</h4><hr>
<p>then方法是promise的最基本的方法，返回的是两个回调，一个成功的回调，一个失败的回调，实现过程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">then(onFulFilled, onRejected) &#123;</span><br><span class="line">	if (this.status === &#x27;resolved&#x27;) &#123; //成功状态的回调</span><br><span class="line">		onFulFilled(this.value);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.status === &#x27;rejected&#x27;) &#123;//失败状态的回调</span><br><span class="line">		onRejected(this.reason);</span><br><span class="line">	&#125;</span><br><span class="line">	// 当前既没有完成 也没有失败</span><br><span class="line">	if (this.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">		// 存放成功的回调</span><br><span class="line">		this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">			onFulFilled(this.value);</span><br><span class="line">		&#125;);</span><br><span class="line">		// 存放失败的回调</span><br><span class="line">		this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">			onRejected(this.reason);</span><br><span class="line">		&#125;);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise A+规范中规定then方法可以链式调用</p>
</blockquote>
<p>在promise中，要实现链式调用返回的结果是返回一个新的promise，第一次then中返回的结果，无论是成功或失败，都将返回到下一次then中的成功态中，但在第一次then中如果抛出异常错误，则将返回到下一次then中的失败态中</p>
<h4 id="链式调用成功时"><a href="#链式调用成功时" class="headerlink" title="链式调用成功时"></a><strong>链式调用成功时</strong></h4><p>链式调用成功会返回值，有多种情况，根据举的例子，大致列出可能会发生的结果。因此将链式调用返回的值单独写一个方法。方法中传入四个参数，分别是p2,x,resolve,reject,p2指的是上一次返回的promise，x表示运行promise返回的结果，resolve和reject是p2的方法。则代码写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(p2,x,resolve,reject)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>返回结果不能是自己</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise((resovle,reject) =&gt; &#123;</span><br><span class="line">    return p;     //返回的结果不能是自己，</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当返回结果是自己时，永远也不会成功或失败，因此当返回自己时，应抛出一个错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(p2,x,resolve,reject)&#123;</span><br><span class="line">    if(px===x)&#123;</span><br><span class="line">        return reject(new TypeError(&#x27;自己引用自己了&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>返回结果可能是promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(promise2,x,resolve,reject)&#123;</span><br><span class="line">    //判断x是不是promise</span><br><span class="line">    //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互</span><br><span class="line">    if(promise2 === x)&#123;//不能自己等待自己完成</span><br><span class="line">        return reject(new TypeError(&#x27;循环引用&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">    // x是除了null以外的对象或者函数</span><br><span class="line">    if(x !=null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;))&#123;</span><br><span class="line">        let called;//防止成功后调用失败</span><br><span class="line">        try&#123;//防止取then是出现异常  object.defineProperty</span><br><span class="line">            let then = x.then;//取x的then方法 &#123;then:&#123;&#125;&#125;</span><br><span class="line">            if(typeof then === &#x27;function&#x27;)&#123;//如果then是函数就认为他是promise</span><br><span class="line">                //call第一个参数是this，后面的是成功的回调和失败的回调</span><br><span class="line">                then.call(x,y =&gt; &#123;//如果Y是promise就继续递归promise</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    resolvePromise(promise2,y,resolve,reject)</span><br><span class="line">                &#125;,r =&gt; &#123; //只要失败了就失败了</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    reject(r);  </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;//then是一个普通对象，就直接成功即可</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (e)&#123;</span><br><span class="line">            if(called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;//x = 123 x就是一个普通值 作为下个then成功的参数</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回结果可能为一个普通值，则直接  resolve(x);</li>
<li>Promise一次只能调用成功或者失败</li>
</ul>
<p>也就是当调用成功就不能再调用失败了，如果两个都调用的时候，哪个先调用就执行哪一个。代码部分还是上面那部分</p>
<p>最后给大家附上全部源码，供大家仔细品读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(promise2,x,resolve,reject)&#123;</span><br><span class="line">    //判断x是不是promise</span><br><span class="line">    //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互</span><br><span class="line">    if(promise2 === x)&#123;//不能自己等待自己完成</span><br><span class="line">        return reject(new TypeError(&#x27;循环引用&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">    // x是除了null以外的对象或者函数</span><br><span class="line">    if(x !=null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;))&#123;</span><br><span class="line">        let called;//防止成功后调用失败</span><br><span class="line">        try&#123;//防止取then是出现异常  object.defineProperty</span><br><span class="line">            let then = x.then;//取x的then方法 &#123;then:&#123;&#125;&#125;</span><br><span class="line">            if(typeof then === &#x27;function&#x27;)&#123;//如果then是函数就认为他是promise</span><br><span class="line">                //call第一个参数是this，后面的是成功的回调和失败的回调</span><br><span class="line">                then.call(x,y =&gt; &#123;//如果Y是promise就继续递归promise</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    resolvePromise(promise2,y,resolve,reject)</span><br><span class="line">                &#125;,r =&gt; &#123; //只要失败了就失败了</span><br><span class="line">                    if(called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    reject(r);  </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;//then是一个普通对象，就直接成功即可</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (e)&#123;</span><br><span class="line">            if(called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;//x = 123 x就是一个普通值 作为下个then成功的参数</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">    constructor (executor)&#123;</span><br><span class="line">        //默认状态是等待状态</span><br><span class="line">        this.status = &#x27;panding&#x27;;</span><br><span class="line">        this.value = undefined;</span><br><span class="line">        this.reason = undefined;</span><br><span class="line">        //存放成功的回调</span><br><span class="line">        this.onResolvedCallbacks = [];</span><br><span class="line">        //存放失败的回调</span><br><span class="line">        this.onRejectedCallbacks = [];</span><br><span class="line">        let resolve = (data) =&gt; &#123;//this指的是实例</span><br><span class="line">            if(this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">                this.value = data;</span><br><span class="line">                this.status = &quot;resolved&quot;;</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn =&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        let reject = (reason) =&gt; &#123;</span><br><span class="line">            if(this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">                this.reason = reason;</span><br><span class="line">                this.status = &#x27;rejected&#x27;;</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn =&gt; fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;//执行时可能会发生异常</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;catch (e)&#123;</span><br><span class="line">            reject(e);//promise失败了</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    then(onFuiFilled,onRejected)&#123; </span><br><span class="line">        //防止值得穿透 </span><br><span class="line">        onFuiFilled = typeof onFuiFilled === &#x27;function&#x27; ? onFuiFilled : y =&gt; y;</span><br><span class="line">        onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected :err =&gt; &#123;throw err;&#125;        </span><br><span class="line">        let promise2;//作为下一次then方法的promise</span><br><span class="line">       if(this.status === &#x27;resolved&#x27;)&#123;</span><br><span class="line">           promise2 = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">               setTimeout(() =&gt; &#123;</span><br><span class="line">                  try&#123;</span><br><span class="line">                        //成功的逻辑 失败的逻辑</span><br><span class="line">                        let x = onFuiFilled(this.value);</span><br><span class="line">                        //看x是不是promise 如果是promise取他的结果 作为promise2成功的的结果</span><br><span class="line">                        //如果返回一个普通值，作为promise2成功的结果</span><br><span class="line">                        //resolvePromise可以解析x和promise2之间的关系</span><br><span class="line">                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                  &#125;catch(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                  &#125; </span><br><span class="line">               &#125;,0)</span><br><span class="line">           &#125;); </span><br><span class="line">       &#125; </span><br><span class="line">       if(this.status === &#x27;rejected&#x27;)&#123;</span><br><span class="line">            promise2 = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let x = onRejected(this.reason);</span><br><span class="line">                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。</span><br><span class="line">                        resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,0)</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       //当前既没有完成也没有失败</span><br><span class="line">       if(this.status === &#x27;pending&#x27;)&#123;</span><br><span class="line">           promise2 = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">               //把成功的函数一个个存放到成功回调函数数组中</span><br><span class="line">                this.onResolvedCallbacks.push( () =&gt;&#123;</span><br><span class="line">                    setTimeout(() =&gt; &#123;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            let x = onFuiFilled(this.value);</span><br><span class="line">                            resolvePromise(promise2,x,resolve,reject);</span><br><span class="line">                        &#125;catch(e)&#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,0)</span><br><span class="line">                &#125;);</span><br><span class="line">                //把失败的函数一个个存放到失败回调函数数组中</span><br><span class="line">                this.onRejectedCallbacks.push( ()=&gt;&#123;</span><br><span class="line">                    setTimeout(() =&gt; &#123;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            let x = onRejected(this.reason);</span><br><span class="line">                            resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">                        &#125;catch(e)&#123;</span><br><span class="line">                            reject(e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,0)</span><br><span class="line">                &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       return promise2;//调用then后返回一个新的promise</span><br><span class="line">    &#125;</span><br><span class="line">    catch (onRejected) &#123;</span><br><span class="line">        // catch 方法就是then方法没有成功的简写</span><br><span class="line">        return this.then(null, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.all = function (promises) &#123;</span><br><span class="line">    //promises是一个promise的数组</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        let arr = []; //arr是最终返回值的结果</span><br><span class="line">        let i = 0; // 表示成功了多少次</span><br><span class="line">        function processData(index, data) &#123;</span><br><span class="line">            arr[index] = data;</span><br><span class="line">            if (++i === promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(function (data) &#123;</span><br><span class="line">                processData(i, data)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        for (var i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 生成一个成功的promise</span><br><span class="line">Promise.resolve = function(value)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; resolve(value);</span><br><span class="line">&#125;</span><br><span class="line">// 生成一个失败的promise</span><br><span class="line">Promise.reject = function(reason)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; reject(reason));</span><br><span class="line">&#125;</span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;;</span><br><span class="line">    dfd.promise = new Promise( (resolve, reject) =&gt;  &#123;</span><br><span class="line">        dfd.resolve = resolve;</span><br><span class="line">        dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    return dfd</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Promise;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年11月27日 13:23</p>
        <p>原始链接： <a class="post-url" href="/2021/11/27/promise/" title="Promise的理解和手撕代码">https://wskytop.gitee.io/2021/11/27/promise/</a></p>
        <footer>
            <a href="https://wskytop.gitee.io">
                <img src="/images/logo.png" alt="Hugh">
                Hugh
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wskytop.gitee.io/2021/11/27/promise/&title=《Promise的理解和手撕代码》 — Hugh's Blog&pic=https://wskytop.gitee.ioimages/logo.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wskytop.gitee.io/2021/11/27/promise/&title=《Promise的理解和手撕代码》 — Hugh's Blog&source=专注 WEB 开发的网站" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wskytop.gitee.io/2021/11/27/promise/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Promise的理解和手撕代码》 — Hugh's Blog&url=https://wskytop.gitee.io/2021/11/27/promise/&via=https://wskytop.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wskytop.gitee.io/2021/11/27/promise/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://wskytop.gitee.io/2021/11/27/promise/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/js/" class="color3">js</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFPromise%EF%BC%9F%E6%88%91%E4%BB%AC%E7%94%A8Promise%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="post-toc-text">一、什么是Promise？我们用Promise来解决什么问题?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E3%80%81es6-promise%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8"><span class="post-toc-text">二、es6 promise用法大全</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#then-%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">then 链式操作的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#reject%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">reject的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#catch%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">catch的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#all%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">all的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#race%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A%E8%B0%81%E8%B7%91%E7%9A%84%E5%BF%AB%EF%BC%8C%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83"><span class="post-toc-text">race的用法：谁跑的快，以谁为准执行回调</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B9%E6%8D%AEpromiseA-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84promise"><span class="post-toc-text">三、根据promiseA+实现一个自己的promise</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%88%90%E5%8A%9F%E5%92%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="post-toc-text">步骤一：实现成功和失败的回调方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9Athen%E6%96%B9%E6%B3%95%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="post-toc-text">步骤二：then方法链式调用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%88%90%E5%8A%9F%E6%97%B6"><span class="post-toc-text">链式调用成功时</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
  
    <a href="/2021/11/25/git/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Git 常用命令</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="promise" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvMglhx4';
        var conf = 'dc4a7139a3f67732c71e03c4b993aeeb';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 Hugh<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://wskytop.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/notes/">notes</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 20px;">js</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 20px;">js</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>